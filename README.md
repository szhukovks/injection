# Перехоплення системних функцій в середовищі ОС Windows #



### Навіщо це може знадобитися ? ###
Слово 'перехоплення' говорить само за себе. Це може знадобитися в будь-якій ситуації коли виникає необхідність відстежити факт виклику системної функції, змінити вхідні  або  вихідні аргументи. Типовим сценарієм для такого завдання є реверс-інжиніринг або зміна поведінки ПО, у випадку коли немає доступу до програмного коду. *Слід зазначити що в завданнях пов'язаних з реверсом-інжинірингом, перехоплення це швидше допоміжний інструмент, тоді як на перший план виходить дізасемблювання та аналіз даних.*

Вперше з цим завданням я зіткнувся у 2001 році - раптово виявилося що ПО яким користувався (Fractal Design Painter 5) відмовлялося запускатися якщо в системі було встановлено більш ніж 4 GiB оперативної пам'яті.  Одна справа коли пам'яті мало, але досить курйозно  виглядає ситуація у випадку з "зайвою" пам'яттю.

![До](https://raw.githubusercontent.com/szhukovks/injection/master/images/not_enought_memory.png)


Винуватцем виявилась системна функція [GlobalMemoryStatus](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366586%28,v=vs.85%29.aspx ), яка повертала некоректне значення (-1).


Перехоплення і коректування параметрів цієї функції дозволили елегантно вийти з ситуації без складного дизасемблювання чи патчинга  виконуваного файла.  Штучно було зроблено щоб функція GlobalMemoryStatus завжди повертала обьем  пам'яті рівний 2 GiB, додаку який запросив цю інформацію.


![Після](https://raw.githubusercontent.com/szhukovks/injection/master/images/splashscreen.png)

Кажучи про перехоплення системних функцій, слідує  розділити процес на дві частини:

1. Впровадження (далі "ін'єкції") призначеної для користувача функції в адресний простір процесу, для якого повинне здійснюватися перехоплення.  Функція для ін'єкції має бути оформлена у вигляді модуля DLL .

2. Підміна точки входу у функції із оригінальної, на призначену користувачем .


### Способи ін'єкції ###

#### Remote thread ####
Даний спосіб найбільш поширений. Windows API надає функцію "CreateRemoteThread" яка створює потік в контексті будь-якого іншого процесу.
Один з аргументів функції вказує на точку входу в функцію потоку (thread worker). Трюк полягає в тому, що в якості точки входу вказується адреса системної функції LoadLibrary, а в якості додаткового параметра передається посилання (pointer) на строку зі шляхом до до  ін'єкціруемой DLL.
Це працює тому, що для всіх процесів базовий адрес бібліотеці User32.dll однаковий, і відповідно адреса LoadLibrary також.
*Базова адреса завантаження системних DLL однакова в контексті однієї сесії. Після перезавантаження ця адреса може змінитися, але також буде однакова для всіх процесів. Така поведінка реалізується механізмом ASLR (Address Space Layout Randomization), який по ідеї повинен ускладнити експлуатацію деяких вразливостей ОС.*


#### Windows hook ####
Даний спосіб ґрунтується на можливості ставити призначені для користувача "пастки" на події певного роду (ввід даних за допомогою клавіатури або миші, наприклад) для Windows додатків.

#### AppInit_DLLs ####
```
\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
```

DLL модулі перераховані в цьому розділі реєстру будуть автоматично завантажуватися в усі процеси, при їх старті (*крім тих процесів які не використовують функції з user32.dll, але таких вкрай мало*).


Даний спосіб ще з часів Windows XP позначений Microsoft як не рекомендований до використання (deprecated), з огляду на потенційну небезпеку і уразливості.



### Методи підміни точки входу ###

#### Модифікація таблиці імпорту ####
Таблиця імпорту модуля містить в собі адреси імпортованих з DLL функцій.
Адреси вираховуються при завантаженні DLL, з урахуванням базової адреси. Кожен раз коли викликається яка-небудь функція реалізована в DLL, адреса відповідної функції витягується з таблиці, і проводиться її виклик.
Таким чином змінивши адресу будь-якої системної функції, на адресу власної - буде викликана остання.
Як було сказано раніше перехоплення, як правило, полягає в зміні вхідних або вихідних даних перехопленої функції. Тобто для перехоплення, як мінімум, треба зберегти адресу оригінальної функції для виклику пізніше. Оригінальна функція зробить основну роботу, а функція  користувача  може здійснювати  обробку параметрів до чи після виклика оригінальної функції.
Для успішної заміни адреси важливо щоб виконуваний модуль був з прилінкованою (linked)  бібліотекою імпорту, відповідної DLL. Бібліотека імпорту user32.dll практично завжди лінкуеться до всіх модулів. User32.dll, завжди лінкуеться до виконуваних модулів які є Win32 GUI додатками.


#### Установка "трампліну" ####
Цей метод більш складніший в реалізації, але разом з тим він потужніший.
Метод полягає в модифікації частини виконуваного коду функції.
У самий початок тіла функції записується машинна інструкція, для безумовного переходу в зону користувацької функції ( "трамплін"), де виробляються необхідні маніпуляції над параметрами.
У C/C ++ при виконанні функції формується т.зв. stack-frame, який використовується для передачі параметрів у функцію (а також містить адресу повернення). Використання "трампліну" ламає звичайну роботу з stack-frame, яку генерує компілятор,
тому цей метод вимагає особливої ​​процедури відновлення стека в кінці виконання.
На відміну від методу модифікації таблиці імпорту, цей спосіб буде працювати навіть якщо до виконуваного модулю не була прилінкована  відповідна бібліотека імпорту.

Вищесказане справедливо не тільки по відношенню до системних функцій, а й будь-яких інших які:
1. реалізовані в DLL.
2. експортуються по імені або за індексом.
3. відомий прототип функції, і порядок передачі аргументів до стеку (calling conversion).


#### Проксі DLL ####
Існують ще декілька інших способів для перехоплення системних викликів, серед яких найбільш легко реалізовний це написання користувацької DLL модуля, який буде завантажуватися замість оригінального. Всі виклики функцій потім будуть перенаправлені в оригінальний модуль (проксінг).

### Резюме ###
Перехоплення системних функцій стане гідним інструментом в арсеналі будь-якого фахівця, який займається реверс-інжинірингом, або в разі коли вихідні коди загублені (legacy) а треба щось виправити. При всьому, при цьому даний інструмент не вважається чимось хакерських або "кримінальним" з точки зору Windows - цей механізм активно використовувався з найраніших версій ОС Windows самою Microsoft. На базі цих засобів реалізовані деякі антивіруси та системи моніторингу потенційних загроз.


### Демо проект ###
Посилання на GitHub репозиторій : [https://github.com/szhukovks/injection.git](https://github.com/szhukovks/injection.git)

Демо проект складається з трьох підпроектів :

1. example-app  - Windows GUI додаток, який  виводить текст "Hello, World" на канві посеред вікна, за допомогою функції DrawTextW

2. injection - DLL модуль для ін'єкції, з  функцією користувача. Модифікований DrawTextW, підміняє будь який оригінальний текст на "Goodbye, World".

3. injector - виробляє запуск тестового додатка, а також здійснює ін'єкцію і перехоплення оригінальної функції DrawTextW. Існує можливість впроваджувати DLL в уже запущені процеси -  для цього в треба не створювати новий процес через Win32 API CreateProcess (...), а отримувати доступ до  вже існуючого через OpenProcess (...).


![Тестовий додаток](https://raw.githubusercontent.com/szhukovks/injection/master/images/before.png)  ![Тестовий додаток після перехоплення  функції DrawTextW](https://raw.githubusercontent.com/szhukovks/injection/master/images/after.png)


### Ключові моменти
#### injector/injector.cpp ####

```
  SECURITY_DESCRIPTOR sd = {0};
  SECURITY_ATTRIBUTES		sa = { 0 };

  // Створення процесу, для якого буде здійснено перехоплення системної функції
  auto success = ::CreateProcessW(szAppPath, L"", &sa, nullptr, FALSE, CREATE_SUSPENDED, nullptr, nullptr, &si, &pi);

  //збереження дескриптора створеного процесу, для подальшого використання з CreateRemoteThread

  hApp = pi.hProcess;
  hThread = pi.hThread;
```

```
// Підготовка до запуску "віддаленого" потоку, в контексті раніше створеного процесу.
auto pLoadLibraryW = ::GetProcAddress(GetModuleHandleW(L"Kernel32"), "LoadLibraryW");

auto path_cchar = wcslen(szInjectionDll) + 1;
auto block_size = path_cchar * sizeof(wchar_t);

//створення блоку пам'яті в адресному просторі нового процесу (в який повинна бути ін'єкцірована DLL)
auto szPathMemory = ::VirtualAllocEx(hApp, NULL, block_size, MEM_COMMIT, PAGE_READWRITE);

//копіювання шляху до ін'єкцірованого модулю
SIZE_T count = 0;
auto success = ::WriteProcessMemory(hApp, szPathMemory, szInjectionDll, block_size,  &count);
DWORD dwThreadId = 0;

//запуск віддаленого потоку, в результаті якого буде викликана функція LoadLibrary в контексті створеного процесу
HANDLE hThread = ::CreateRemoteThread(hApp, nullptr, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryW, szPathMemory, 0, &dwThreadId);
```


#### injection/dllmain.cpp ####
```
//Функція яка буде викликатися замість системної. Для тестового прикладу відбувається підміна оригінальної строки на "Goodbye, World".
int FAR WINAPI  DrawTextW_Custom(HDC dc, LPCTSTR text, int length, LPRECT rc, UINT format)
{
 auto szText = L"Goodbye, World";
 int len = (int)wcslen(szText);

 return g_pDrawTextW(dc, szText, len, rc, format);
}

```


```
bool intercept()
{
	if (!g_pDrawTextW) { return false; }

  //Виклик допоміжної функції для безпосереднього зміни адреси функції в таблиці імпорту.
  //Функція ImageDirectoryEntryToData дозволяє отримати доступ до цієї таблиці, і реалізована в спеціалізованій отладочной бібліотеці dbghelp.dll (входить в дистрибутив Windows)
  return apply_IAT_patch("User32.dll", g_pDrawTextW, &DrawTextW_Custom, ::GetModuleHandle(NULL));
}
```


```
//перехоплення відбувається в стандартній точці входу  DLL модуля, при першому завантаженні в адресний простір процесу.
BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID) {
	switch (ul_reason_for_call) {
		case DLL_PROCESS_ATTACH: {		
			if (!intercept())  {
        //...  
```
